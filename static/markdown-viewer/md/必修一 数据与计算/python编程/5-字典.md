# 5-字典

## 1. 字典的介绍

字典（dictionary）是Python中的一种数据结构，它是由键值对（key-value pair）组成的集合。每个键是唯一的，且必须是不可变的数据类型（如字符串、数字、元组），值可以是任何数据类型。

### 字典的形式

字典可以通过大括号 `{}` 定义，键值对之间用逗号 `,` 分隔，键(key)和值(value)之间用冒号 `:` 分隔。

![图片](/_uploads/photos/abcdefg.png "width=300")

```python
s = {'姓名': '小明', '年龄': 16, '性别': '男'}
print(s['姓名'])   #输出小明
s['学校'] = 'YWHS' #新增字典的键值对
print(s['学校'])   #输出YWHS
```

### 字典的基本特点：

- 字典保持插入顺序，不会自动排序。
- 键是唯一的，不可变的。
- 值是可变的，可以是任何数据类型。

## 2. 字典的枚举

可以使用 keys()、values()、`items()` 三种方法来枚举字典中的键值对。

```python
s = {'姓名': '小明', '年龄': 16, '性别': '男'}
```

##### 方式一（枚举键keys()）：

```python
for i in s:
    print(i, '是', s[i])
```

或者

```python
for i in s.keys():
    print(i, '是', s[i])
```

##### 方式二（枚举值values()）：

```python
for i in s.values():
    print(i)
```

##### 方式三（同时枚举items()）：

```python
for i1,i2 in s.items():
    print(i1, '是', i2)
```

## 【课堂习题】

1.以下哪个方法可以返回字典中所有的键？

A. person.keys()    B. person.items()    C. person.values()    D. person.get_keys()

2.下面能检查字典d中是否存在键值“name”的语句是

A."name" == d.keys()    B."name" == d    C."name" in d    D."name" in ditems()

3.下面能检查字典d中是否存在内容“name”的语句是

A."name" == d.values()    B."name" == d    C."name" in d.values    D."name" in ditems()

4.下列代码输出是

person = {'name': 'Alice', 'age': 25}
person['age'] = 26
print(person)

A. {'name': 'Alice', 'age': 25}
B. {'name': 'Alice', 'age': 26}
C. {'name': 'Alice', 'age': 25, 'age': 26}
D. {'name': 'Alice'}

5.统计字符串"hello world"中每个字符出现的次数，请完成填空

```python
def count_characters(s):
    char_count = {}
    for char in _____:
        if char in char_count:
            __________
        else:
            char_count[char] = 1
    return char_count
s = "hello world"
result = count_characters(s)
print(result)
```

6.合并两个字典，如果有相同的键，值相加

```python
def merge_dicts(dict1, dict2):
    merged_dict = dict1
    for key, value in _____.items():
        if key in merged_dict:
            merged_dict[key] += value
        else:
            __________
    return merged_dict

# 示例
dict1 = {'a': 1, 'b': 2, 'c': 3}
dict2 = {'b': 3, 'c': 4, 'd': 5}
result = merge_dicts(dict1, dict2)
print(result)  # 输出: {'a': 1, 'b': 5, 'c': 7, 'd': 5}
```

7.统计英文单词出现次数

读取文件“2022浙江高考英语.txt”，统计其中出现次数超过1次的英文单词

```python
import codecs
f = codecs.open("2022浙江高考英语.txt", "r", "utf-8")
s = f.read()
n = len(s)
words = []
word = ""
for i in range(n):
    c = s[i]
    if "A"<=c<="Z": c = __________   #大写转小写字母
        
    if "a"<=c<="z":
        word += c
    else:
        if word != "":
            words += [word]
            word = ""
print(words)
d = dict()
for i in words:
    if i not in d.keys():
        d[i] = 1
    else:
        __________
for a,b in d.items():
    if __________:
        print(a,b)
```

## 扩展阅读
### 字典的原理
#### 字典的本质

在python中，字典的本质是哈希算法，那么从字典的使用方法中，我们可以理解哈希的概念

**哈希英文HASH，译为散列，本质是将一个元素映射至另一个元素，最多的应用是查找**

其核心有两点：

①**设计哈希函数**

②解决哈希冲突

#### 初步实现

那么我们就用一个具体的字典的例子来看哈希的原理

先看问题：

```
输入一些姓名，查看各自出现的次数：
fly、miku、rin、fly
```

首先有一点比较明确

这些数据是字符串，但如果我们操作的是数字，那么只需利用计数思想，即**桶**的思维，令 f[i] 表示 i 出现的次数，问题便解决了：

```python
f = [0]*1000
a = [2,4,3,5,6]
for i in a:
    f[i] += 1
#计数思想如此可以通过f[i]判断i出现了几次
```

但是这些姓名不是数字啊

没关系我们可以把它转换成数字

这个过程就叫**哈希**

转换的方法有很多，不同的方法即不同的**哈希算法**，常见的有连加法、连乘法、取模法、进制法、公式法等等

我们采取最简单的一种——连加法，将所有字母的ASCII码全部加起来

```python
def Hash(str): #注意不能用hash，会和系统关键字冲突
    res = 0
    for i in str:
        res += ord(i)
    return res
```

好，在这个基础上，我们再来解决刚才的问题：

```python
def Hash(str): #注意不能用hash，会和系统关键字冲突
    res = 0
    for i in str:
        res += ord(i)
    return res
a = ["fly", "miku", "rin", "fly"]
f = [0]*1000
for i in a:
    f[Hash(i)] += 1 #对比一下第一份代码，其实仍旧是计数思想
for i in a:
    print(i, f[Hash(i)])
```

（输出后容易发现fly被输出了两次，这里相当于python关键字的枚举，本来需要用一点手段优化一下，我们现在只讨论哈希，所以就暂时不处理这点细节了）

#### 哈希冲突的产生

这样一来，我们发现这个问题解决了

但也很容易发现没有完全解决

例如数据：

```python
a = ["fly", "miku", "rin", "ylf"]
```

这组数据显然4个名字各不相同，但是输出是错误的，将fly和ylf误认为同一个关键字，这个叫做**哈希冲突**

怎么解决这个问题，我们需要考虑如何避免重复，一个简单的办法是换一个哈希算法，采用**进制法**：将26个字母看成一个26进制的数字，利用进制转换转为十进制数字作为哈希值

```python
def Hash(str):
    res = 0
    for i in str:
        res = res * 26 + ord(i)-97 #这里我们假设只有小写字母，简化一下代码
    return res
```

但这样一来我们会发现数组越界了，毕竟转换的数字过大

于是我们扩大数组的范围，当扩到1000000时，终于能容纳下这些数字了

```python
f = [0]*1000000
```

但是名字再长一点怎么办？

如果要你存储的不是一个单词，而是一篇文章怎么办？

数组的容量是有上限的，所以这个方法不治本，需要考虑其他方法

#### 取巧的办法 双哈希

这个和链表的关系不大，算是支线

既然全部加起来会冲突，那我们可以换一套算法再哈希一边，两次哈希全部重复的概率总是比较小的，如果你能接纳这种小概率事件带来的影响，那么双哈希不失为一个解决办法，实在不行你还可以三哈希、四哈希...这样概率更小，不过这样一来容易导致程序常数起飞，不如正规算法，所以实际情况下无人使用过多次数的哈希

#### 哈希冲突的解决——挂链法

哈希冲突的标准解决方案有**开放地址法**与**挂链法**，本文只介绍链表相关的挂链法，关于开放地址法由于和链表无关所以不多赘述，感兴趣的可以自己搜索

我们先看一下哈希存数据的模型（以连加法为例）

![](https://flying.zj.cn/_uploads/photos/cOGUAmXsg7SvQwE8.png)

产生的问题在于fly和ylf的哈希值是一样的，即哈希值冲突，那么能不能把他们放到一起？

这样一来，便出现了**集合**的模型，每个哈希值都**挂**着一个链表，这个链表存储了所有哈希值和它相等的原始数据，见图

![](https://flying.zj.cn/_uploads/photos/GMXCN8oWixWQKHyy.png)

这里的节点数据域有两个值，其中node[p][0]是p节点的原始数据即字符串，node[1]是p节点内容的出现次数

那么查询的时候，我们就需要先根据哈希值找到链表头，然后跑一遍这个链表，看看里面的原始数据是否和查询关键字一样，如果都不一样，我们添加链表节点，如果有一样的，我们将链表的node[p][1] + 1

具体实现还是需要先理清思路一步一步来

首先是构建链表，需要开辟节点数组，还需要一个头节点的数组，因为不同的哈希值各自对应一个链表，所以有几种哈希值就要有几个链表头

```python
head = [-1] * 100000 #差不多够了，也可以利用%符号，让哈希值继续减少至自己想要的范围
node = [[] for i in range(1000)] #这里的范围只需控制在数据个数以内就可以了
k = 0 #仍旧是用于去node数组申请空间

def Hash(str): #哈希函数还是要带上
    res = 0
    for i in str:
        res += ord(i)
    return res
a = ["fly", "miku", "rin", "fly"]

for i in a:
    add(i)  #将字符串i添加至链表，若已存在则对应节点中表示数量的值+1，若不存在则新建链表节点，具体写法待会再说
for i in a:
    print(i, find(i))  #find函数查询i的具体次数，本质是遍历链表，具体待会说
```

好，程序主体结束了，接下来准备对付add()和find()函数

这两个函数在标准的哈希写法中都是少不了的，即增加数据和查询数据，和计数思想比起来感觉麻烦了很多，但是逻辑上是一样的

对于add(str)，我们要经历下面几步：

①将str转为哈希值sum（ASCII总和）

②根据哈希值找到对应链表的头节点head[sum]，在这个链表中，存储着所有的哈希值为sum的字符串

③跑一遍链表，看看str是否已经有了，若有了，则对应的节点数据node[p][1]+1，否则新增节点，为了效率，我们还是新增到链表头

OVER

代码实现：

```python
def add(str):
    global k
    p = head[Hash(str)] #找到头节点
    while p!=-1 and node[p][0]!=str: #跑一遍链表
        p = node[p][2]
    if p==-1: #不存在，新增节点
        k += 1
        node[k] = [str, 1, head[Hash(str)]]
        head[Hash(str)] = k
    else: #存在，对应内容+1
        node[p][1] += 1
```

接下来是find(str)函数，返回str对应出现的次数，会发现和add()几乎是一样的，因为都要遍历链表

```python
def find(str):
    p = head[Hash(str)] #找到头节点
    while p!=-1 and node[p][0] != str: #跑一遍链表
        p = node[p][2]
    if p==-1: #查找失败，不存在该字符串
        return 0
    else:
        return node[p][1] #返回出现次数
```